# Pipeline para desplegar todas las aplicaciones (Zipkin y SonarQube) en Kubernetes de Azure
# Trigger: Manual
# Parámetros: environment (dev, stage, prod, all)

trigger: none  # Solo trigger manual

parameters:
  - name: environment
    displayName: 'Ambiente de despliegue'
    type: string
    default: 'dev'
    values:
      - dev
      - stage
      - prod
      - all

variables:
  - group: k8s-config  # Variable group con configuración de K8s
  serviceConnection: 'Azure-Kubernetes-Service'  # Service connection name

stages:
- stage: DeployZipkin
  displayName: 'Desplegar Zipkin'
  jobs:
  - job: DeployZipkin
    displayName: 'Desplegar Zipkin'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    
    - task: Bash@3
      displayName: 'Instalar envsubst y Azure CLI'
      inputs:
        targetType: 'inline'
        script: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

    - task: AzureCLI@2
      displayName: 'Login a Azure'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Conectado a Azure"

    - task: Bash@3
      displayName: 'Aplicar manifests de Zipkin'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Desplegando Zipkin en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            if [ -z "$RESOURCE_GROUP" ] || [ -z "$CLUSTER_NAME" ]; then
              echo "ERROR: Variables no configuradas para el ambiente $env"
              exit 1
            fi
            
            echo "Conectando al cluster $CLUSTER_NAME en resource group $RESOURCE_GROUP"
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            # Crear namespace si no existe
            kubectl create namespace $env --dry-run=client -o yaml | kubectl apply -f -
            
            # Aplicar manifests con substitución de variables
            export NAMESPACE=$env
            envsubst < k8s/zipkin/deployment.yaml | kubectl apply -f -
            envsubst < k8s/zipkin/service.yaml | kubectl apply -f -
            
            echo "Zipkin desplegado exitosamente en $env"
          done

    - task: Bash@3
      displayName: 'Verificar despliegue de Zipkin'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Verificando despliegue de Zipkin en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            kubectl get deployment zipkin -n $env
            kubectl get service zipkin -n $env
            kubectl rollout status deployment/zipkin -n $env --timeout=300s
          done

- stage: DeploySonarQube
  displayName: 'Desplegar SonarQube'
  dependsOn: DeployZipkin
  jobs:
  - job: DeploySonarQube
    displayName: 'Desplegar SonarQube'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    
    - task: Bash@3
      displayName: 'Instalar envsubst y Azure CLI'
      inputs:
        targetType: 'inline'
        script: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

    - task: AzureCLI@2
      displayName: 'Login a Azure'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Conectado a Azure"

    - task: Bash@3
      displayName: 'Aplicar manifests de SonarQube'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Desplegando SonarQube en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            if [ -z "$RESOURCE_GROUP" ] || [ -z "$CLUSTER_NAME" ]; then
              echo "ERROR: Variables no configuradas para el ambiente $env"
              exit 1
            fi
            
            echo "Conectando al cluster $CLUSTER_NAME en resource group $RESOURCE_GROUP"
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            # Crear namespace si no existe
            kubectl create namespace $env --dry-run=client -o yaml | kubectl apply -f -
            
            # Aplicar manifests con substitución de variables
            export NAMESPACE=$env
            export SONARQUBE_DB_PASSWORD="$(SONARQUBE_DB_PASSWORD)"
            envsubst < k8s/sonarqube/secret.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/pvc.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/postgres-deployment.yaml | kubectl apply -f -
            
            # Esperar a que la base de datos esté lista
            echo "Esperando a que la base de datos esté lista..."
            kubectl wait --for=condition=ready pod -l app=sonarqube-db -n $env --timeout=300s
            
            envsubst < k8s/sonarqube/deployment.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/service.yaml | kubectl apply -f -
            
            echo "SonarQube desplegado exitosamente en $env"
          done

    - task: Bash@3
      displayName: 'Verificar despliegue de SonarQube'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Verificando despliegue de SonarQube en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            kubectl get deployment sonarqube -n $env
            kubectl get deployment sonarqube-db -n $env
            kubectl get service sonarqube -n $env
            kubectl get service sonarqube-db -n $env
            kubectl rollout status deployment/sonarqube -n $env --timeout=600s
          done
