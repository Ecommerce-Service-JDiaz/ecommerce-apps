# Pipeline para desplegar SonarQube en Kubernetes de Azure
# Trigger: Manual
# Parámetros: environment (dev, stage, prod, all)

trigger: none  # Solo trigger manual

parameters:
  - name: environment
    displayName: 'Ambiente de despliegue'
    type: string
    default: 'dev'
    values:
      - dev
      - stage
      - prod
      - all

variables:
  - group: k8s-config  # Variable group con configuración de K8s
  serviceConnection: 'Azure-Kubernetes-Service'  # Service connection name

stages:
- stage: DeploySonarQube
  displayName: 'Desplegar SonarQube'
  jobs:
  - job: Deploy
    displayName: 'Desplegar SonarQube en Kubernetes'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    
    - task: Bash@3
      displayName: 'Instalar envsubst y Azure CLI'
      inputs:
        targetType: 'inline'
        script: |
          sudo apt-get update
          sudo apt-get install -y gettext-base
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

    - task: AzureCLI@2
      displayName: 'Login a Azure'
      inputs:
        azureSubscription: '$(serviceConnection)'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Conectado a Azure"

    - task: Bash@3
      displayName: 'Aplicar manifests de SonarQube'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Desplegando SonarQube en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            if [ -z "$RESOURCE_GROUP" ] || [ -z "$CLUSTER_NAME" ]; then
              echo "ERROR: Variables no configuradas para el ambiente $env"
              exit 1
            fi
            
            echo "Conectando al cluster $CLUSTER_NAME en resource group $RESOURCE_GROUP"
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            # Crear namespace si no existe
            kubectl create namespace $env --dry-run=client -o yaml | kubectl apply -f -
            
            # Aplicar manifests con substitución de variables
            export NAMESPACE=$env
            export SONARQUBE_DB_PASSWORD="$(SONARQUBE_DB_PASSWORD)"
            envsubst < k8s/sonarqube/secret.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/pvc.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/postgres-deployment.yaml | kubectl apply -f -
            
            # Esperar a que los PVCs estén bound
            echo "Esperando a que los PVCs estén aprovisionados..."
            kubectl wait --for=condition=bound pvc/sonarqube-data-pvc -n $env --timeout=120s || true
            kubectl wait --for=condition=bound pvc/sonarqube-extensions-pvc -n $env --timeout=120s || true
            kubectl wait --for=condition=bound pvc/sonarqube-logs-pvc -n $env --timeout=120s || true
            kubectl wait --for=condition=bound pvc/sonarqube-db-pvc -n $env --timeout=120s || true
            
            # Esperar a que el pod esté running
            echo "Esperando a que el pod de la base de datos esté running..."
            kubectl wait --for=condition=ready pod -l app=sonarqube-db -n $env --timeout=600s || {
              echo "ERROR: El pod de la base de datos no está listo. Diagnóstico:"
              kubectl get pods -l app=sonarqube-db -n $env
              kubectl get pvc -n $env
              kubectl describe pod -l app=sonarqube-db -n $env
              POD_NAME=$(kubectl get pods -l app=sonarqube-db -n $env -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
              if [ -n "$POD_NAME" ]; then
                echo "Logs del pod $POD_NAME:"
                kubectl logs $POD_NAME -n $env --tail=50
              fi
              exit 1
            }
            
            envsubst < k8s/sonarqube/deployment.yaml | kubectl apply -f -
            envsubst < k8s/sonarqube/service.yaml | kubectl apply -f -
            
            echo "SonarQube desplegado exitosamente en $env"
          done

    - task: Bash@3
      displayName: 'Verificar despliegue'
      inputs:
        targetType: 'inline'
        script: |
          ENVIRONMENTS="${{ parameters.environment }}"
          
          if [ "$ENVIRONMENTS" = "all" ]; then
            ENVIRONMENTS="dev stage prod"
          fi
          
          for env in $ENVIRONMENTS; do
            echo "Verificando despliegue en ambiente: $env"
            
            # Obtener variables según el ambiente
            if [ "$env" = "dev" ]; then
              RESOURCE_GROUP="$(resourceGroup_dev)"
              CLUSTER_NAME="$(aksClusterName_dev)"
            elif [ "$env" = "stage" ]; then
              RESOURCE_GROUP="$(resourceGroup_stage)"
              CLUSTER_NAME="$(aksClusterName_stage)"
            elif [ "$env" = "prod" ]; then
              RESOURCE_GROUP="$(resourceGroup_prod)"
              CLUSTER_NAME="$(aksClusterName_prod)"
            fi
            
            az aks get-credentials \
              --resource-group "$RESOURCE_GROUP" \
              --name "$CLUSTER_NAME" \
              --overwrite-existing
            
            kubectl get deployment sonarqube -n $env
            kubectl get deployment sonarqube-db -n $env
            kubectl get service sonarqube -n $env
            kubectl get service sonarqube-db -n $env
            kubectl rollout status deployment/sonarqube -n $env --timeout=600s
          done
